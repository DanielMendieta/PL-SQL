 ¬øCu√°ndo usar Cursores?

Un cursor expl√≠cito se declara manualmente, se abre, obtiene datos y se cierra, 
se usan cuando se necesita recorrer varias filas en un bloque PL/SQL, 
mientras que los impl√≠citos solo manejan una sola fila por vez.

Un cursor impl√≠cito lo maneja autom√°ticamente Oracle cuando se ejecuta una consulta SELECT INTO, INSERT, UPDATE o DELETE.




‚úÖ Cuando necesitas procesar filas una por una.
‚úÖ Para recorrer datos en bucles dentro de PL/SQL.
‚úÖ Cuando una consulta devuelve varias filas y necesitas control sobre ellas.

üöÄ Conclusi√≥n:
Un cursor permite recorrer los resultados de una consulta fila por fila dentro de PL/SQL, √∫til cuando necesitas procesar datos de manera secuencial.

DECLARE
    CURSOR c_empleados IS  
        SELECT nombre, salario FROM empleados WHERE salario > 2000;
    v_nombre empleados.nombre%TYPE;
    v_salario empleados.salario%TYPE;
BEGIN
    OPEN c_empleados;  -- Abrir el cursor
    LOOP
        FETCH c_empleados INTO v_nombre, v_salario;  -- Obtener fila
        EXIT WHEN c_empleados%NOTFOUND;  -- Salir cuando no haya m√°s filas
        DBMS_OUTPUT.PUT_LINE('Empleado: ' || v_nombre || ' - Salario: ' || v_salario);
    END LOOP;
    CLOSE c_empleados;  -- Cerrar el cursor
END;
/
¬øQu√© pasa aqu√≠?
‚úî DECLARE CURSOR guarda la consulta.
‚úî OPEN abre el cursor.
‚úî FETCH obtiene una fila a la vez.
‚úî EXIT WHEN %NOTFOUND detiene el bucle cuando no hay m√°s filas.
‚úî CLOSE cierra el cursor.

---CONSULTA ANTERIOR PERO CON UN BUCLE FOR;

BEGIN
    FOR r_empleado IN (SELECT nombre, salario FROM empleados WHERE salario > 2000) LOOP
        DBMS_OUTPUT.PUT_LINE('Empleado: ' || r_empleado.nombre || ' - Salario: ' || r_empleado.salario);
    END LOOP;
END;
/

‚úî No necesitas DECLARE CURSOR, OPEN, FETCH ni CLOSE.
‚úî El FOR recorre autom√°ticamente cada fila de la consulta.
‚úî r_empleado es un registro temporal que contiene los valores de cada fila.

üöÄ Conclusi√≥n

Si solo necesitas recorrer filas sin un control manual, usa un FOR.
Es m√°s corto, m√°s limpio y evita errores al manejar el cursor autom√°ticamente.

--------------------------------------------------------------------------------------------------

ATRIBUTO PARA CURSORES

‚úÖ %FOUND ‚Üí Hay m√°s filas (sigue el bucle).
‚úÖ %NOTFOUND ‚Üí No hay m√°s filas (se detiene el bucle).
‚úÖ %ROWCOUNT ‚Üí Cuenta filas recuperadas.
‚úÖ %ISOPEN ‚Üí Verifica si el cursor est√° abierto.


--------------------------------------------------------------------------------------------------

BEGIN
    -- Contador de filas
    DECLARE
        v_count NUMBER := 0;
    BEGIN
        FOR I IN (SELECT id, nombre, salario FROM empleados ORDER BY nombre DESC) LOOP
            DBMS_OUTPUT.PUT_LINE('Empleado: ' || I.id || ' - Nombre: ' || I.nombre || ' - Salario: ' || I.salario);
            
            -- Contar filas procesadas
            v_count := v_count + 1;
            DBMS_OUTPUT.PUT_LINE('Cantidad de empleados procesados: ' || v_count);
        END LOOP;
    END;
END;
/

--------------------------------------------------------------------------------------------------

EJEMPLO SENCILLO CON FOR

Usa un cursor expl√≠cito para recorrer los productos de la tabla.
Muestra en la salida el nombre y el precio de cada producto utilizando DBMS_OUTPUT.PUT_LINE.
Det√©n el bucle cuando ya no haya m√°s productos.


BEGIN
    FOR I IN (SELECT nombre, precio FROM productos) LOOP
            DBMS_OUTPUT.PUT_LINE('Nombre: ' || I.nombre || ' Precio: ' || I.precio);
     END LOOP;
END; 
/
--------------------------------------------------------------------------------------------------

Consigna:

    Usa un cursor expl√≠cito para recorrer todos los productos de la categor√≠a 3.
    Aumenta el precio de cada producto en un 5%.
    Muestra en la salida el nombre del producto y el nuevo precio despu√©s del incremento.
    Si el nuevo precio de un producto es mayor a 100, muestra el mensaje: "Producto caro".
    Despu√©s de procesar todos los productos de la categor√≠a, muestra el total de productos procesados.

BEGIN
    -- Actualiza el precio de los productos de la categor√≠a 3
    UPDATE productos SET precio = precio * 1.05 WHERE categoria_id = 3;

    -- Recorre los productos de la categor√≠a 3
    FOR I IN (SELECT nombre, precio FROM productos WHERE categoria_id = 3) LOOP
        DBMS_OUTPUT.PUT_LINE('Producto: ' || I.nombre || ' Nuevo Precio: ' || I.precio);
        IF I.precio > 100 THEN 
            DBMS_OUTPUT.PUT_LINE('¬°Producto caro!');
        END IF;
    END LOOP;

END;
/
DE LA FORMA LARGA SER√çAS ASI:

DECLARE
    CURSOR cursor_productos IS
        SELECT nombre, precio FROM productos WHERE categoria_id = 3;
    nombre productos.nombre%TYPE;
    precio productos.precio%TYPE;
BEGIN
    -- Abrir el cursor
    OPEN cursor_productos;
    
    -- Recorrer las filas
    LOOP
        FETCH cursor_productos INTO nombre, precio;
        EXIT WHEN cursor_productos%NOTFOUND;  -- Salir cuando no haya m√°s filas
        
        -- Aplicar el aumento del 5% al precio
        precio := precio * 1.05;
        
        -- Mostrar el nombre y el nuevo precio
        DBMS_OUTPUT.PUT_LINE('Producto: ' || nombre || ' Nuevo Precio: ' || precio);
        
        -- Verificar si el precio es mayor a 100
        IF precio > 100 THEN
            DBMS_OUTPUT.PUT_LINE('¬°Producto caro!');
        END IF;
    END LOOP;
    
    -- Cerrar el cursor
    CLOSE cursor_productos;
END;
/
--------------------------------------------------------------------------------------------------
MENDIETA & SANTIAGO

Obt√©n una lista de empleados que trabajan en el mismo departamento que un empleado espec√≠fico 
(elige un employee_id existente) y muestra su nombre, apellido y salario. 
Ordena los resultados por salario en orden descendente.

Proceso Almacenado con Cursor

/*Obt√©n una lista de empleados que trabajan en el mismo departamento que un empleado espec√≠fico 
(elige un employee_id existente) y muestra su nombre, apellido y salario. 
Ordena los resultados por salario en orden descendente.*/  

SET SERVEROUTPUT ON;

CREATE OR REPLACE PROCEDURE prueba (p_id IN NUMBER) IS
    CURSOR c_dep IS 
        SELECT FIRST_NAME AS Nombre,
               LAST_NAME AS Apellido,
               SALARY AS Salario
        FROM employees
        WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM employees E WHERE E.EMPLOYEE_ID = p_id)
        ORDER BY SALARY DESC;
BEGIN
    FOR reg IN c_dep LOOP
        DBMS_OUTPUT.PUT_LINE('Nombre completo: ' || reg.Nombre || ' ' || reg.Apellido || ' - Salario: ' || reg.Salario);
    END LOOP;
END;
/

EXEC prueba(105);

--------------------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE etl_procesar_empleados IS
    CURSOR c_empleados IS 
        SELECT id, nombre, salario FROM empleados_raw;  -- Extraer todos los empleados
BEGIN
    FOR reg IN c_empleados LOOP
        -- Validar si el salario es nulo o negativo
        IF reg.salario IS NULL OR reg.salario < 0 THEN
            INSERT INTO auditoria_etl (empleado_id, mensaje)
            VALUES (reg.id, 'Error: Salario inv√°lido, no procesado.');
            CONTINUE;  -- Salta a la siguiente iteraci√≥n del loop
        END IF;

        -- Insertar en la tabla correspondiente seg√∫n el salario
        IF reg.salario < 3000 THEN
            INSERT INTO empleados_bajo (id, nombre, salario)
            VALUES (reg.id, UPPER(reg.nombre), reg.salario);
        ELSIF reg.salario BETWEEN 3000 AND 7000 THEN
            INSERT INTO empleados_medio (id, nombre, salario)
            VALUES (reg.id, UPPER(reg.nombre), reg.salario);
        ELSE
            INSERT INTO empleados_alto (id, nombre, salario)
            VALUES (reg.id, UPPER(reg.nombre), reg.salario);
        END IF;

        -- Registrar en auditor√≠a
        INSERT INTO auditoria_etl (empleado_id, mensaje)
        VALUES (reg.id, 'Empleado procesado correctamente.');

    END LOOP;

    COMMIT;
END;
/















