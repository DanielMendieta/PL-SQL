üìå Escenario:
Una empresa necesita procesar los datos de empleados y registrarlos en diferentes tablas seg√∫n su salario.

1Ô∏è‚É£ Tabla de origen: empleados_raw (datos sin procesar).
2Ô∏è‚É£ Tablas de destino:

empleados_bajo ‚Üí Empleados con salario menor a 3000.
empleados_medio ‚Üí Empleados con salario entre 3000 y 7000.
empleados_alto ‚Üí Empleados con salario mayor a 7000.
3Ô∏è‚É£ Requisitos del ETL:
Cada empleado debe insertarse en la tabla correcta seg√∫n su salario.
Se debe registrar cada inserci√≥n en una tabla de auditor√≠a (auditoria_etl).
Si un empleado tiene un salario negativo o nulo, no se debe procesar y debe registrarse el error en la auditor√≠a.
4Ô∏è‚É£ Se debe usar:
Cursores (porque cada fila requiere l√≥gica personalizada antes de insertarse).
Procedimientos almacenados para estructurar el proceso.
Tabla de auditor√≠a para registrar el procesamiento.

-- Tabla de empleados sin procesar (origen)
CREATE TABLE empleados_raw (
    id NUMBER PRIMARY KEY,
    nombre VARCHAR2(100),
    salario NUMBER
);

-- Tablas de destino seg√∫n rango salarial
CREATE TABLE empleados_bajo (
    id NUMBER PRIMARY KEY,
    nombre VARCHAR2(100),
    salario NUMBER
);

CREATE TABLE empleados_medio (
    id NUMBER PRIMARY KEY,
    nombre VARCHAR2(100),
    salario NUMBER
);

CREATE TABLE empleados_alto (
    id NUMBER PRIMARY KEY,
    nombre VARCHAR2(100),
    salario NUMBER
);

-- Tabla de auditor√≠a para registrar el procesamiento
CREATE TABLE auditoria_etl (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    empleado_id NUMBER,
    mensaje VARCHAR2(200),
    fecha_procesado DATE DEFAULT SYSDATE
);


2Ô∏è‚É£ Crear el Procedimiento con Cursor

CREATE OR REPLACE PROCEDURE etl_procesar_empleados IS
    TYPE empleados_tab IS TABLE OF empleados_raw%ROWTYPE;
    v_empleados empleados_tab;
    v_lote CONSTANT NUMBER := 100; -- Define el tama√±o del lote para commit en lotes

    -- Cursor para extraer los empleados
    CURSOR c_empleados IS 
        SELECT id, nombre, salario FROM empleados_raw;

BEGIN
    OPEN c_empleados;
    LOOP
        FETCH c_empleados BULK COLLECT INTO v_empleados LIMIT v_lote;
        EXIT WHEN v_empleados.COUNT = 0;

        FOR i IN 1..v_empleados.COUNT LOOP
            BEGIN
                -- Validar si el salario es nulo o negativo
                IF v_empleados(i).salario IS NULL OR v_empleados(i).salario < 0 THEN
                    INSERT INTO auditoria_etl (empleado_id, mensaje)
                    VALUES (v_empleados(i).id, 'Error: Salario inv√°lido, no procesado.');
                    CONTINUE; -- Salta a la siguiente iteraci√≥n
                END IF;

                -- Insertar en la tabla correspondiente seg√∫n el salario
                IF v_empleados(i).salario < 3000 THEN
                    INSERT INTO empleados_bajo (id, nombre, salario)
                    VALUES (v_empleados(i).id, UPPER(v_empleados(i).nombre), v_empleados(i).salario);
                ELSIF v_empleados(i).salario BETWEEN 3000 AND 7000 THEN
                    INSERT INTO empleados_medio (id, nombre, salario)
                    VALUES (v_empleados(i).id, UPPER(v_empleados(i).nombre), v_empleados(i).salario);
                ELSE
                    INSERT INTO empleados_alto (id, nombre, salario)
                    VALUES (v_empleados(i).id, UPPER(v_empleados(i).nombre), v_empleados(i).salario);
                END IF;

                -- Registrar en auditor√≠a
                INSERT INTO auditoria_etl (empleado_id, mensaje)
                VALUES (v_empleados(i).id, 'Empleado procesado correctamente.');

            EXCEPTION
                WHEN OTHERS THEN
                    INSERT INTO auditoria_etl (empleado_id, mensaje)
                    VALUES (v_empleados(i).id, 'Error en procesamiento: ' || SQLERRM);

            END;
        END LOOP;

        COMMIT; -- Realiza commit en lotes

    END LOOP;
    CLOSE c_empleados;
END;
/


üìå ¬øPor qu√© es NECESARIO un Cursor aqu√≠?
‚úî Cada empleado debe insertarse en una tabla diferente seg√∫n su salario.
‚úî Si el salario es inv√°lido, el registro no debe procesarse, pero s√≠ registrarse el error.
‚úî Se ejecutan m√∫ltiples inserciones por cada empleado (en la tabla correcta + auditor√≠a).
‚úî El uso de INSERT INTO SELECT no funcionar√≠a aqu√≠, porque cada fila tiene reglas distintas.


-- Insertar datos de prueba
INSERT INTO empleados_raw VALUES (1, 'Carlos L√≥pez', 2500);
INSERT INTO empleados_raw VALUES (2, 'Ana M√©ndez', 5000);
INSERT INTO empleados_raw VALUES (3, 'Pedro G√≥mez', 8000);
INSERT INTO empleados_raw VALUES (4, 'Laura P√©rez', NULL);  -- Salario inv√°lido
INSERT INTO empleados_raw VALUES (5, 'Jorge Ruiz', -1000);  -- Salario inv√°lido

COMMIT;

-- Ejecutar el ETL
BEGIN
    etl_procesar_empleados;
END;
/

-- Verificar los resultados
SELECT * FROM empleados_bajo;
SELECT * FROM empleados_medio;
SELECT * FROM empleados_alto;
SELECT * FROM auditoria_etl;


üìå Resultado esperado despu√©s de ejecutar el ETL
üìä Tablas de destino
empleados_bajo tendr√° a Carlos L√≥pez (2500) ‚Üí convertido a may√∫sculas.
empleados_medio tendr√° a Ana M√©ndez (5000).
empleados_alto tendr√° a Pedro G√≥mez (8000).
Laura P√©rez y Jorge Ruiz NO ser√°n insertados porque sus salarios son inv√°lidos.
üìä Tabla de auditor√≠a (auditoria_etl)
Carlos, Ana y Pedro tendr√°n el mensaje "Empleado procesado correctamente."
Laura y Jorge tendr√°n "Error: Salario inv√°lido, no procesado."
-----------------------------------------------------------------------------------------------

3Ô∏è‚É£  Creamos un Job para ejecutar el ETL autom√°ticamente

BEGIN
    DBMS_SCHEDULER.create_job (
        job_name        => 'JOB_ETL_EMPLEADOS',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN etl_procesar_empleados; END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=DAILY; BYHOUR=07; BYMINUTE=0; BYSECOND=0',
        enabled         => TRUE
    );
END;
/


üìå ¬øQu√© hace este Job?
‚úî Ejecuta el ETL autom√°ticamente cada d√≠a a las 7 AM.
‚úî Evita la ejecuci√≥n manual del procedimiento.









